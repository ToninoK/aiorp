{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"AIORP","text":"<p>WARNING</p> <p>This package is still in development and should be used with care</p> <p>AIORP is a lightweight, asynchronous reverse proxy package for Python built on top of aiohttp. It provides a simple yet powerful interface for creating reverse proxies with minimal configuration.</p> <p>Key features:</p> <ul> <li>Easy to set up and configure</li> <li>Built on aiohttp for high performance</li> <li>Support for custom request/response handling</li> <li>Flexible routing capabilities</li> <li>Python 3.10+ support</li> </ul> <p>Get started quickly with our Quickstart guide, dive deeper with the Advanced Guide, or explore the complete API Reference.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install AIORP using pip:</p> <pre><code>pip install aiorp\n</code></pre>"},{"location":"#creators","title":"Creators","text":"<p>AIORP is maintained by ToninoK.</p> <p>If you'd like to contribute, please check out the contribution guidelines [TBD].</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Want to try it out ASAP to see if it suits your use-case? Let's set up a minimal example for you.</p>"},{"location":"quickstart/#installation","title":"Installation","text":"<p>Let's get the package installed for starters. In your virtual environment run the following:</p> <pre><code>pip install aiorp\n</code></pre> <p>Once this completes you should have both <code>aiorp</code> and <code>aiohttp</code> installed.</p>"},{"location":"quickstart/#minimal-example","title":"Minimal example","text":"<pre><code>from aiohttp import web\nfrom aiorp import HTTPProxyHandler, ProxyContext\nfrom aiorp.context import configure_contexts\n\nTARGET_URL = yarl.URL(\"https://your-target-server.com\")  # (1)!\n\napp = web.Application()\n\nctx = ProxyContext(TARGET_URL)\nconfigure_contexts(app, [ctx])\n\nhandler = HTTPProxyHandler(context=ctx)\n\napp.router.add_get(\"/{path:.*}\", handler)  # (2)!\n\nweb.run_app(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <ol> <li>Replace with your target server URL</li> </ol>"},{"location":"quickstart/#what-did-i-just-read","title":"What did I just read?","text":"<p>If you are confused a bit about what you just read above, no worries, we'll walk through the example and discuss what's happening.</p>"},{"location":"quickstart/#imports","title":"Imports","text":"<pre><code>from aiohttp import web\nfrom aiorp import HTTPProxyHandler, ProxyContext, configure_contexts\n# ...\n</code></pre> <p>You should probably understand what's happening here. We are just importing all the packages we need. We need:</p> <ul> <li>the <code>web</code> module from <code>aiohttp</code> for setting up the application</li> <li><code>HTTPProxyHandler</code> for defining the proxy handler</li> <li><code>ProxyContext</code> to be able to set the context for requests targeting a   specific server</li> <li><code>configure_contexts</code> to set up some context management for the contexts we   define</li> </ul>"},{"location":"quickstart/#defining-the-app","title":"Defining the App","text":"<pre><code># ...\napp = web.Application()\n# ...\nweb.run_app(app, host=\"0.0.0.0\", port=8000)\n</code></pre> <p>Nothing out of the ordinary here, we just need to set up the <code>aiohttp</code> server application we want to use for our proxy server.</p>"},{"location":"quickstart/#defining-the-proxy-context","title":"Defining the proxy context","text":"<pre><code># ...\nctx = ProxyContext(TARGET_URL)\nconfigure_contexts(app, [ctx])\n# ...\n</code></pre> <p>To define where our handler should proxy the requests you need to feed it a <code>ProxyContext</code> instance. <code>ProxyContext</code> is a class in charge of handling the proxied request contexts targeting a specific URL. What falls under the jurisdiction of a proxy context? Well pretty much anything related to your proxy request:</p> <ul> <li>Session -&gt; the session that manages connections to the target server</li> <li><code>ProxyRequest</code> -&gt; a wrapper around incoming and outgoing requests</li> <li><code>ProxyResponse</code> -&gt; a wrapper around incoming and outgoing responses</li> <li>State -&gt; simple dictionary allowing you to share data between handlers   during the request lifetime</li> </ul> <p>If you need any further information on the above-mentioned, you should find it all within the documentation.</p> <p>The <code>configure_contexts</code> function on the other hand is very simple. It is just in charge of making sure that the sessions are properly opened and closed during the application lifecycle.</p>"},{"location":"quickstart/#defining-our-handler","title":"Defining our handler","text":"<pre><code># ...\nhandler = HTTPProxyHandler(context=ctx)\n\napp.router.add_get(\"/{path:.*}\", handler)\n# ...\n</code></pre> <p>Finally, we can define our handler and attach it to the application. What exactly does the handler do? It accepts a <code>web.Request</code> object, and proxies it to the target server defined in the context, returning the target server response.</p> <p>In the second line we simply route all of the GET requests to the handler.</p>"},{"location":"quickstart/#where-to-next","title":"Where to next?","text":"<p>This is just the bare-bones functionality, if you want a more complex example, you should check out the Tutorial. After that, I recommend checking out the Advanced documentation and the API reference.</p>"},{"location":"tutorial/","title":"Tutorial","text":"<p>This is a more extensive run-through of the package functionality. In this guide we'll set up an reverse-proxy with the following requirements:</p> <ul> <li>Proxy requests to two target servers</li> <li>Different authentication to different servers</li> <li>The application should also be behind its own authentication</li> <li>Support compressing response for the user</li> </ul> <p>Already bored?</p> <p>Don't feel like listening to me yap? You can jump to the prepared example found here</p>"},{"location":"tutorial/#scenario","title":"Scenario","text":"<p>Let's take the scenario of an ERP platform. It has multiple partners which manage their business through it. An ERP system is complex enough for it to need multiple different services, rather than a large monolithic service. So the platform likely needs a reverse-proxy in front of its services to handle the partner authentication and serve all of its content from a single point of entry.</p> <p>For our scenario, we'll look at two services an ERP would need to provide:</p> <ul> <li>Content storage</li> <li>Transactions</li> </ul> <p>These will be the target services we will proxy with our reverse-proxy.</p>"},{"location":"tutorial/#target-servers","title":"Target servers","text":"<p>The prerequisite to our proxy is obviously something to proxy the requests to. Not to lose time on writing these, since it's not the point of the exercise, you can find the codes for the two example servers here.</p> <p>Take some time to inspect them, see what endpoints they expose, and how they work. TL;DR: they have some CRUD endpoints expecting</p>"},{"location":"tutorial/#environment","title":"Environment","text":"<p>Let's initialize the environment first and install the package. In this guide we'll use <code>uv</code> for managing our dependencies. The following commands will create an environment and install the package inside it.</p> <pre><code>uv init aiorp-example --bare\ncd aiorp-example\nuv add aiorp pyjwt\nsource .venv/bin/activate\n</code></pre> <p>Tooling</p> <p>You'll see me using <code>http</code> commands in the shell. I'm using <code>httpie</code> for testing but you can use <code>curl</code> or whatever tool you feel comfortable with</p>"},{"location":"tutorial/#folder-structure","title":"Folder structure","text":"<p>Let's prepare our folder structure</p> <pre><code>proxy/\n\u251c\u2500\u2500 src/\n\u2502   \u251c\u2500\u2500 middlewares/              # The shared proxy middlewares\n\u2502   \u251c\u2500\u2500 routers/                  # The routers for our target servers\n\u2502   \u251c\u2500\u2500 utils/                    # Utility functionality we might need\n\u2502   \u2514\u2500\u2500 app.py                    # Main application entry point\n\u251c\u2500\u2500 pyproject.toml                # Project dependencies\n\u2514\u2500\u2500 uv.lock                       # Locked dependencies\n</code></pre> <p>Having prepared our structure we're ready to start writing our app.</p>"},{"location":"tutorial/#the-aiohttp-app","title":"The AIOHTTP app","text":"<p>Let's start by creating our AIOHTTP application. Create a new file <code>src/app.py</code> with the following content:</p> <pre><code>from aiohttp import web\n\n\ndef create_app() -&gt; web.Application:\n    \"\"\"Create and configure the application\"\"\"\n    app = web.Application()\n\n    return app\n\n\nif __name__ == \"__main__\":\n    app = create_app()\n    web.run_app(app, host=\"localhost\", port=8080)\n</code></pre> <p>We did no special magic we just configured our application. You can try running it with:</p> <pre><code>python3 -m src.app\n</code></pre>"},{"location":"tutorial/#authentication","title":"Authentication","text":"<p>Let's add some authentication to it. In the <code>src/utils</code> folder create a file called <code>auth.py</code>.</p> <pre><code>from datetime import datetime, timedelta, timezone\n\nimport jwt\nfrom aiohttp import web\n\n\nJWT_SECRET = \"your-super-secret-jwt-key\"  # (1)\nJWT_ALGORITHM = \"HS256\"\nJWT_EXP_DELTA_SECONDS = 3600  # 1hr\n\n\nUSERS = {  # (2)!\n    \"WAL001\": {\n        \"password\": \"wal001\",\n        \"role\": \"user\",\n    },\n}\n\n\ndef create_token(user_id: str) -&gt; str:  # (3)!\n    \"\"\"Create a new JWT token for the user\"\"\"\n    payload = {\n        \"user_id\": user_id,\n        \"exp\": datetime.now(tz=timezone.utc) + timedelta(seconds=JWT_EXP_DELTA_SECONDS),\n        \"iat\": datetime.now(tz=timezone.utc),\n    }\n    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)\n\n\ndef verify_token(token: str) -&gt; dict:  # (4)!\n    \"\"\"Verify the JWT token and return the payload\"\"\"\n    try:\n        payload = jwt.decode(\n            token, JWT_SECRET, algorithms=[JWT_ALGORITHM], verify_exp=True\n        )\n        return payload\n    except jwt.ExpiredSignatureError:\n        raise web.HTTPUnauthorized(reason=\"Token has expired\")\n    except jwt.InvalidTokenError:\n        raise web.HTTPUnauthorized(reason=\"Invalid token\")\n</code></pre> <ol> <li> <code>openssl rand -hex 32</code></li> <li>In the real world please don't use a dictionary </li> <li>Simple function which takes the user_id and creates a token with the user_id.</li> <li>Function that tries to decode the token and verify that it isn't expired</li> </ol> <p>Our file has some simple functionality to generate and verify a generated token. Let's put some of it to use in our <code>app.py</code> file.</p> <pre><code>from aiohttp import web\nfrom src.utils.auth import USERS, create_token\n\n\nasync def login(request):\n    \"\"\"Handle user login\"\"\"\n    data = await request.json()\n    username = data.get(\"username\")\n    password = data.get(\"password\")\n\n    if not username or not password:\n        raise web.HTTPBadRequest(reason=\"Username and password are required\")\n\n    user = USERS.get(username)\n    if not user or user[\"password\"] != password:\n        raise web.HTTPUnauthorized(reason=\"Invalid username or password\")\n\n    token = create_token(username)\n    return web.json_response(\n        {\"token\": token, \"user\": {\"username\": username, \"role\": user[\"role\"]}}\n    )\n\ndef create_app() -&gt; web.Application:\n  app = web.Application()\n\n  app.router.add_post(\"/login\", login)\n\n  return app\n#...\n</code></pre> <p>Great! Our app now has authentication. You can run the server and test it:</p> <pre><code>http POST localhost:8080/login username=WAL001 password=wal001\n</code></pre> <p>You can store the token you get as we'll need it later.</p>"},{"location":"tutorial/#transactions-handler","title":"Transactions Handler","text":"<p>Great now that authentication is out of the way, we can start adding our proxy handlers. Let's start with the transactions handler.</p> <pre><code>from typing import Any, AsyncGenerator\n\nfrom aiorp import HTTPProxyHandler, ProxyContext\nfrom yarl import URL\n\nTRANSACTIONS_API_KEY = \"transactions-secret-key-123\"  # (1)!\nTRANSACTIONS_URL = URL(\"http://localhost:8001\")\n\ntransactions_ctx = ProxyContext(url=TRANSACTIONS_URL)  # (2)!\ntransactions_handler = HTTPProxyHandler(context=transactions_ctx)  # (3)!\n\n\n@transactions_handler.default  # (4)!\nasync def transactions_auth(ctx: ProxyContext) -&gt; AsyncGenerator[None, Any]:\n    \"\"\"Add transactions API key to requests\"\"\"\n    ctx.request.headers[\"X-API-Key\"] = TRANSACTIONS_API_KEY\n    yield  # (5)!\n</code></pre> <ol> <li>This is our example API key for our transactions service</li> <li><code>ProxyContext</code> will take care of setting up a session to the target service</li> <li>The proxy handler is the brains, it will forward all of the requests to    the target service. It also supports attaching middleware functions    to execute before and after the proxy request.</li> <li>This decorator is used to register a proxy middleware function on our    handler. The middleware function will do pre-request actions and    post-request(response) actions.</li> <li>The code up to the yield will execute before the request,    everything afterwards will happen after the request is executed.    Within the function, one can use the <code>ProxyContext</code> that offers access to    the <code>ProxyRequest</code> and <code>ProxyResponse</code> objects.</li> </ol> <p>With this setup now, we configured a handler to forward authenticated requests to the transactions service. We obviously still need to connect it to our app so let's do that now.</p> <p>Import the <code>transactions_handler</code>, and then attach it to the router below the last defined login route. Note that we need to leave the path open to proxy all requests our service can accept.</p> <p>Also we need to import the <code>transactions_ctx</code> and the <code>configure_contexts</code>, and call the function with the app and context. This will assure proper session handling.</p> <pre><code>    # ...\n    configure_contexts(app, [transactions_ctx])  # (1)!\n\n    app.router.add_route(\n        \"*\", \"/shops/{shop_id:[A-Za-z0-9]+}/transactions{tail:.*}\", transactions_handler\n    )\n    # ...\n</code></pre> <ol> <li>We need to configure the context to start sessions when we start the app    and close them when the app is turned off</li> </ol> <p>We are now ready to test the communication with the target service. Start both the proxy server and the target transactions server.</p> <pre><code>http GET localhost:8080/shops/BBY001/transactions 'Authorization:Bearer &lt;token-from-login&gt;'\n</code></pre> <p>If you get a response with test transactions inside, it means we did everything correctly.</p> <p>The inventory handler</p> <p>The setup for the second service is the same, you can try doing it yourself, or just copy it from the example in the Github repository. You don't need it for the example, it's there for your practice and to demonstrate how to set up a proxy with multiple target servers.</p>"},{"location":"tutorial/#loading-the-user","title":"Loading the user","text":"<p>More often than not, it might be useful to know which user is interacting with our service . We have this information in the token already but we just need to load it. Let's create a handler that will do just that.</p> <p>In the <code>src/middlewares</code> directory create an <code>auth.py</code> file.</p> <pre><code>from typing import Any, AsyncGenerator\n\nfrom aiohttp import web\nfrom aiorp import ProxyContext\n\nfrom src.utils.auth import verify_token\n\n\nasync def auth_middleware(ctx: ProxyContext) -&gt; AsyncGenerator[None, Any]:\n    \"\"\"Middleware to handle authentication for proxy requests\"\"\"\n    auth_header = ctx.request.headers.get(\"Authorization\")  # (1)!\n    if not auth_header or not auth_header.startswith(\"Bearer \"):\n        raise web.HTTPUnauthorized(reason=\"Missing or invalid Authorization header\")\n\n    token = auth_header.split(\" \")[1]\n    try:\n        payload = verify_token(token)  # (2)!\n        if ctx.state is None:\n            ctx.state = {}\n        ctx.state[\"user\"] = payload  # (3)!\n        yield  # (4)!\n    except web.HTTPUnauthorized as e:\n        raise e\n    except Exception as e:\n        raise web.HTTPUnauthorized(reason=str(e))\n</code></pre> <ol> <li>Load the auth header from the incoming request (<code>in_req</code>)</li> <li>Attempt to verify the token using our utility function</li> <li>Add the user to the current proxy context state</li> <li>Give control back to the http handler</li> </ol> <p>There we have it, an authentication proxy middleware that will store our user in the proxy context.</p> <pre><code># ...\nfrom src.middlewares.auth import auth_middleware\n# ...\ntransactions_handler = HTTPProxyHandler(context=transactions_ctx)\n\ntransactions_handler.add_middleware(\n    ProxyMiddlewareDef(MiddlewarePhase.CLIENT_EDGE, auth_middleware)\n)  # (1)!\n#...\n</code></pre> <ol> <li>Add the middleware <code>CLIENT_EDGE</code> so it executes as soon as possible in the request    lifetime</li> </ol> <p>And what's nice, is that it is reusable, so if you've prepared the <code>inventory</code> service also, you can just plug it in there also</p>"},{"location":"tutorial/#rewriting-the-path","title":"Rewriting the path","text":"<p>Sometimes we might want to have different endpoint paths at our proxy service, compared to the endpoints on the target services. For example some of our target services might serve the same common endpoints (e.g. <code>/api/login</code>). For these cases we need to differ the services. With some service identifier in the proxy endpoint.</p> <p>In other cases, like the one we can see with our services here, we have a common prefix that we can actually fill ourselves: <code>/shops/{shop_id}/</code>. We can find the <code>shop_id</code> in the API key, and use it to build the path. Securing even more access to resources of different users. Let's take a look at how we can easily do this.</p> <p>Add another file to the <code>middlewares</code> module called <code>rewrite.py</code>. Let's define the functionality of rewriting:</p> <pre><code>from posixpath import join\nfrom typing import Any, AsyncGenerator\n\nfrom aiorp import ProxyContext\n\n\nasync def rewrite_shop_path(ctx: ProxyContext) -&gt; AsyncGenerator[None, Any]:\n    user = ctx.state[\"user\"]\n    new_path = join(f\"/shops/{user[\"user_id\"]}\", ctx.request.url.path.lstrip(\"/\"))  # (1)!\n    ctx.request.url = ctx.request.url.with_path(new_path)\n    yield\n</code></pre> <ol> <li>Prefix the path with the correct shop identifier. Don't forget to strip the    prefix slash from the path (second argument), or <code>join</code> will consider it as    absolute path and disregard all else</li> </ol> <p>Having this prepared now, we can include it in our handlers the same way we did with the authorization middleware, for both services.</p> <pre><code># ...\nfrom src.middlewares.rewrite import rewrite_shop_path\n# ...\ntransactions_handler = HTTPProxyHandler(context=transactions_ctx)\n\ntransactions_handler.add_middleware(\n    ProxyMiddlewareDef(MiddlewarePhase.PROXY, rewrite_shop_path)\n)  # (1)!\n</code></pre> <ol> <li>You want to add it as <code>PROXY</code> phase middleware, since we want it executed    after the user is loaded (in <code>CLIENT_EDGE</code> phase)</li> </ol> <p>Just keep in mind to set the middleware phase to <code>PROXY</code>.</p> <p>Let's test it also!</p> <pre><code>http localhost:8080/transactions 'Authorization: Bearer &lt;your-token&gt;'\n</code></pre>"},{"location":"tutorial/#compressing-the-response","title":"Compressing the response","text":"<p>A common requirement is the possibility to add compression to responses to save some  on network traffic. Let' see how to do that with the proxy middlewares.</p> <pre><code>import gzip\nfrom typing import Any, AsyncGenerator\n\nfrom aiohttp import web\n\nfrom aiorp.context import ProxyContext\n\n\nasync def compression_middleware(ctx: ProxyContext) -&gt; AsyncGenerator[None, Any]:\n    \"\"\"Middleware to compress responses before sending to client\"\"\"\n    yield\n\n    accept_encoding = ctx.request.in_req.headers.get(\"Accept-Encoding\", \"\")\n\n    if \"gzip\" not in accept_encoding.lower():\n        return\n\n    if not ctx.response.web_response_set:\n        await ctx.response.set_response()\n\n    if ctx.response.web is web.StreamResponse:\n        return\n\n    content = ctx.response.web.body\n\n    compressed = gzip.compress(content)\n\n    new_response = web.Response(\n        body=compressed,\n        status=ctx.response.web.status,\n        headers=ctx.response.web.headers,\n    )\n\n    new_response.headers[\"Content-Encoding\"] = \"gzip\"\n    new_response.headers[\"Content-Length\"] = str(len(compressed))\n    ctx.response._web = new_response\n</code></pre> <p>Having written this we can add it in the same way we did previously to our handlers</p> <pre><code># ...\ntransactions_handler.add_middleware(\n    ProxyMiddlewareDef(MiddlewarePhase.CLIENT_EDGE, compression_middleware)  # (1)!\n)\n# ...\n</code></pre> <ol> <li>This needs to happen right before we return the response to the client.</li> </ol> <p>Let's test the compression now. The <code>http</code> tool sends an <code>Accept-Encoding</code> header by default with <code>gzip</code> and <code>deflate</code>. If you are using <code>curl</code>, just add the header <code>Accept-Encoding: gzip</code>.</p> <pre><code>http localhost:8080/transactions 'Authorization: Bearer &lt;your-token&gt;'\n</code></pre>"},{"location":"tutorial/#th-th-th-thats-all-folks","title":"Th-th-th-that's all folks!","text":"<p>That should give you a nice overview of the functionality of this package. If you are missing some more functionality, I recommend checking out the Advanced section as you might find some information there perhaps. Otherwise, prepare an Issue on Github with a request. (format for issue all still TBD)</p>"},{"location":"advanced/","title":"Getting started","text":""},{"location":"api_reference/BaseHandler/","title":"BaseHandler","text":"<p>Base handler for proxying requests, not to be used directly.</p> <p>This class provides the basic functionality for handling proxy requests. It should be subclassed to implement specific proxy behavior.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ProxyContext | None</code> <p>Optional proxy context containing target URL and session information.</p> <code>None</code> <code>rewrite</code> <code>Rewrite | None</code> <p>Optional rewrite configuration for modifying request paths.</p> <code>None</code> <code>request_options</code> <code>dict | None</code> <p>Optional dictionary of additional request options to be injected on request. Refer to the <code>ClientSession.request</code> function arguments for the exact options</p> <code>None</code> Source code in <code>aiorp/base_handler.py</code> <pre><code>class BaseHandler:\n    \"\"\"Base handler for proxying requests, not to be used directly.\n\n    This class provides the basic functionality for handling proxy requests.\n    It should be subclassed to implement specific proxy behavior.\n\n    Args:\n        context: Optional proxy context containing target URL and session information.\n        rewrite: Optional rewrite configuration for modifying request paths.\n        request_options: Optional dictionary of additional request options to be injected on\n            request. Refer to the `ClientSession.request` function arguments for the exact options\n    \"\"\"\n\n    def __init__(\n        self,\n        context: ProxyContext | None = None,\n        rewrite: Rewrite | None = None,\n        request_options: dict | None = None,\n    ):\n        self._rewrite = rewrite\n        self.request_options = request_options or {}\n        self.context: ProxyContext | None = context\n\n    async def __call__(self, request: web.Request):\n        \"\"\"Handle incoming requests.\n\n        This method must be implemented by subclasses to provide specific\n        proxy behavior.\n\n        Args:\n            request: The incoming web request to handle.\n\n        Raises:\n            NotImplementedError: Always raised as this method must be implemented\n                by subclasses.\n        \"\"\"\n        raise NotImplementedError(\n            \"The __call__ method must be implemented in a subclass\"\n        )\n</code></pre>"},{"location":"api_reference/BaseHandler/#aiorp.base_handler.BaseHandler.__call__","title":"<code>__call__(request)</code>  <code>async</code>","text":"<p>Handle incoming requests.</p> <p>This method must be implemented by subclasses to provide specific proxy behavior.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming web request to handle.</p> required <p>Raises:</p> Type Description <code>NotImplementedError</code> <p>Always raised as this method must be implemented by subclasses.</p> Source code in <code>aiorp/base_handler.py</code> <pre><code>async def __call__(self, request: web.Request):\n    \"\"\"Handle incoming requests.\n\n    This method must be implemented by subclasses to provide specific\n    proxy behavior.\n\n    Args:\n        request: The incoming web request to handle.\n\n    Raises:\n        NotImplementedError: Always raised as this method must be implemented\n            by subclasses.\n    \"\"\"\n    raise NotImplementedError(\n        \"The __call__ method must be implemented in a subclass\"\n    )\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/","title":"HTTPProxyHandler","text":"<p>               Bases: <code>BaseHandler</code></p> <p>A handler for proxying requests to a remote server.</p> <p>This handler is used to proxy requests to a remote server. It has a call method that is used to handle incoming requests. The handler can be used as a route handler in an aiohttp.web application. It executes specified before and after handlers, before and after the incoming request is proxied.</p> <p>Parameters:</p> Name Type Description Default <code>middlewares</code> <code>List[ProxyMiddlewareDef] | None</code> <p>You can if you want initialize the handler with a set of proxy middlewares right away</p> <code>None</code> <code>error_handler</code> <code>ErrorHandler</code> <p>Callable that is called when an error occurs during the proxied request.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If connection options contain invalid keys.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>class HTTPProxyHandler(BaseHandler):\n    \"\"\"A handler for proxying requests to a remote server.\n\n    This handler is used to proxy requests to a remote server.\n    It has a __call__ method that is used to handle incoming requests.\n    The handler can be used as a route handler in an aiohttp.web application.\n    It executes specified before and after handlers, before and after the\n    incoming request is proxied.\n\n    Args:\n        middlewares: You can if you want initialize the handler with a set of\n            proxy middlewares right away\n        error_handler: Callable that is called when an error occurs during the proxied request.\n\n    Raises:\n        ValueError: If connection options contain invalid keys.\n    \"\"\"\n\n    def __init__(\n        self,\n        *args: Any,\n        middlewares: List[ProxyMiddlewareDef] | None = None,\n        error_handler: ErrorHandler = None,\n        **kwargs: Any,\n    ):\n        \"\"\"Initialize the HTTP proxy handler.\n\n        Args:\n            *args: Variable length argument list.\n            error_handler: Optional callable for handling errors during proxied requests.\n            **kwargs: Arbitrary keyword arguments.\n\n        Raises:\n            ValueError: If connection options contain invalid keys.\n        \"\"\"\n        super().__init__(*args, **kwargs)\n        if self.request_options is not None and any(\n            key in self.request_options\n            for key in [\n                \"method\",\n                \"url\",\n                \"headers\",\n                \"params\",\n                \"data\",\n            ]\n        ):\n            raise ValueError(\n                \"The request options can't contain: method, url, headers, params or data keys.\\n\"\n                \"They should be handled by using the ProxyRequest object in the before handlers.\"\n            )\n\n        self._error_handler = error_handler\n        self._middlewares = defaultdict(list)\n\n        for item in middlewares or []:\n            self._middlewares[item.phase].append(item.middleware)\n\n    async def __call__(self, request: web.Request) -&gt; web.Response | web.StreamResponse:\n        \"\"\"Handle incoming requests.\n\n        This method is called when the handler is used as a route handler in an aiohttp.web app.\n        It executes the middleware chain that was set by the users.\n\n        Args:\n            request: The incoming request to proxy.\n\n        Returns:\n            The response from the external server.\n\n        Raises:\n            ValueError: If proxy context is not set.\n            HTTPInternalServerError: If there's an error during request processing.\n        \"\"\"\n        if self.context is None:\n            raise ValueError(\"Proxy context must be set before the handler is invoked.\")\n        self.context.start_session()\n\n        # We need to copy context since we don't want race conditions\n        # with request or response setting\n        ctx = copy.copy(self.context)\n\n        # Set the request to context\n        ctx.set_request(request)\n\n        if self._rewrite:\n            ctx.request.url = self._rewrite.execute(ctx.request.url)\n\n        # Execute the middleware chain\n        await self._execute_middleware_chain(ctx)\n\n        # Check if the web response was set and set it if it wasn't\n        if not ctx.response.web_response_set:\n            await ctx.response.set_response()\n\n        # Return the response\n        return ctx.response.web\n\n    async def _execute_middleware_chain(self, ctx: ProxyContext):\n        \"\"\"Execute the entire provided middleware chain.\n\n        The chain is executed in order the middlewares were registered,\n        with the pre-yield code executing in that order, and the post-yield\n        executing in reverse order (\"russian doll model\").\n\n        Args:\n            ctx: The ProxyContext to share in each of the middlewares\n\n        Raises:\n            ValueError: If context is not set before execution.\n        \"\"\"\n        sorted_middlewares = sorted(self._middlewares.keys())\n        middleware_generators = defaultdict(list)\n\n        # Start all middleware generators and store them\n        for order_key in sorted_middlewares:\n            middleware_funcs = self._middlewares[order_key]\n            generators = [aiter(func(ctx)) for func in middleware_funcs]\n            await asyncio.gather(*[anext(gen, None) for gen in generators])\n            middleware_generators[order_key] = generators\n\n        # Execute the actual request\n        await self._proxy_middleware(ctx)\n\n        # Resume all middleware generators in reverse order\n        for order_key in reversed(sorted_middlewares):\n            await asyncio.gather(\n                *[anext(gen, None) for gen in middleware_generators[order_key]]\n            )\n\n    async def _proxy_middleware(self, ctx: ProxyContext):\n        \"\"\"The default final middleware in the middleware chain.\n\n        It executes after all other user provided middlewares, and\n        it proxies the request to the target destination.\n\n        Args:\n            context: The proxy context holding the request and response information.\n\n        Raises:\n            ValueError: If proxy request is not set.\n        \"\"\"\n        # Execute the request and check the response\n        await ctx.request.load_content()\n        resp = await ctx.session.request(\n            url=ctx.request.url,\n            method=ctx.request.method,\n            params=ctx.request.params,\n            headers=ctx.request.headers,\n            data=ctx.request.content,\n            **self.request_options,\n        )\n        self._raise_for_status(resp)\n        # Build the proxy response object from the target response\n        ctx.set_response(resp)\n\n    def _raise_for_status(self, response: client.ClientResponse):\n        \"\"\"Check status of request and handle the error properly.\n\n        In case of an error, the error_handler is called if set, otherwise an\n        HTTPInternalServerError is raised with the error message.\n\n        Args:\n            response: The response from the external server.\n\n        Raises:\n            HTTPInternalServerError: If the response status indicates an error.\n        \"\"\"\n        try:\n            response.raise_for_status()\n        except ClientResponseError as err:\n            if self._error_handler:\n                self._error_handler(err)\n            raise HTTPInternalServerError(\n                reason=\"External API Error\",\n                content_type=\"application/json\",\n                text=json.dumps(\n                    {\n                        \"status\": err.status,\n                        \"message\": err.message,\n                    }\n                ),\n            )\n\n    def add_middleware(self, middleware_def: ProxyMiddlewareDef):\n        \"\"\"Register a middleware with explicit ordering.\n\n        It will be registered depending on the order and relative to\n        other defined middlewares. A lower number means sooner registration,\n        while a higher number results in a later registration.\n\n        Args:\n            middleware_def: The proxy middleware definition to add\n        \"\"\"\n        self._middlewares[middleware_def.phase].append(middleware_def.middleware)\n\n    def proxy(self, func: ProxyMiddleware) -&gt; ProxyMiddleware:\n        \"\"\"Register a middleware with default execution order that can yield.\n\n        Executes the pre-yield code before target edge, but after client edge middleware,\n        and the post-yield code after target edge but before client edge middleware.\n\n        Args:\n            func: The middleware function which yields.\n\n        Returns:\n            The decorated middleware function.\n        \"\"\"\n        self.add_middleware(\n            ProxyMiddlewareDef(phase=MiddlewarePhase.PROXY, middleware=func)\n        )\n        return func\n\n    def client_edge(self, func: ProxyMiddleware) -&gt; ProxyMiddleware:\n        \"\"\"Register an client edge middleware that can yield.\n\n        This middleware is registered as first, meaning the code before yield\n        will act before any other one, but code after yield will execute the last.\n\n        Args:\n            func: The middleware function which yields.\n\n        Returns:\n            The decorated middleware function.\n        \"\"\"\n        self.add_middleware(ProxyMiddlewareDef(MiddlewarePhase.CLIENT_EDGE, func))\n        return func\n\n    def target_edge(\n        self, func: Callable[[ProxyContext], AsyncGenerator[None]]\n    ) -&gt; Callable[[ProxyContext], AsyncGenerator[None]]:\n        \"\"\"Register a target edge middleware that can yield.\n\n        This middleware is registered the last.\n        The code before yield will act after all other middlewares. The code after\n        the yield runs before any other middleware.\n\n        Args:\n            func: The middleware function which yields.\n\n        Returns:\n            The decorated middleware function.\n        \"\"\"\n        self.add_middleware(ProxyMiddlewareDef(MiddlewarePhase.TARGET_EDGE, func))\n        return func\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.__call__","title":"<code>__call__(request)</code>  <code>async</code>","text":"<p>Handle incoming requests.</p> <p>This method is called when the handler is used as a route handler in an aiohttp.web app. It executes the middleware chain that was set by the users.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming request to proxy.</p> required <p>Returns:</p> Type Description <code>Response | StreamResponse</code> <p>The response from the external server.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If proxy context is not set.</p> <code>HTTPInternalServerError</code> <p>If there's an error during request processing.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>async def __call__(self, request: web.Request) -&gt; web.Response | web.StreamResponse:\n    \"\"\"Handle incoming requests.\n\n    This method is called when the handler is used as a route handler in an aiohttp.web app.\n    It executes the middleware chain that was set by the users.\n\n    Args:\n        request: The incoming request to proxy.\n\n    Returns:\n        The response from the external server.\n\n    Raises:\n        ValueError: If proxy context is not set.\n        HTTPInternalServerError: If there's an error during request processing.\n    \"\"\"\n    if self.context is None:\n        raise ValueError(\"Proxy context must be set before the handler is invoked.\")\n    self.context.start_session()\n\n    # We need to copy context since we don't want race conditions\n    # with request or response setting\n    ctx = copy.copy(self.context)\n\n    # Set the request to context\n    ctx.set_request(request)\n\n    if self._rewrite:\n        ctx.request.url = self._rewrite.execute(ctx.request.url)\n\n    # Execute the middleware chain\n    await self._execute_middleware_chain(ctx)\n\n    # Check if the web response was set and set it if it wasn't\n    if not ctx.response.web_response_set:\n        await ctx.response.set_response()\n\n    # Return the response\n    return ctx.response.web\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.__init__","title":"<code>__init__(*args, middlewares=None, error_handler=None, **kwargs)</code>","text":"<p>Initialize the HTTP proxy handler.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Variable length argument list.</p> <code>()</code> <code>error_handler</code> <code>ErrorHandler</code> <p>Optional callable for handling errors during proxied requests.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If connection options contain invalid keys.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>def __init__(\n    self,\n    *args: Any,\n    middlewares: List[ProxyMiddlewareDef] | None = None,\n    error_handler: ErrorHandler = None,\n    **kwargs: Any,\n):\n    \"\"\"Initialize the HTTP proxy handler.\n\n    Args:\n        *args: Variable length argument list.\n        error_handler: Optional callable for handling errors during proxied requests.\n        **kwargs: Arbitrary keyword arguments.\n\n    Raises:\n        ValueError: If connection options contain invalid keys.\n    \"\"\"\n    super().__init__(*args, **kwargs)\n    if self.request_options is not None and any(\n        key in self.request_options\n        for key in [\n            \"method\",\n            \"url\",\n            \"headers\",\n            \"params\",\n            \"data\",\n        ]\n    ):\n        raise ValueError(\n            \"The request options can't contain: method, url, headers, params or data keys.\\n\"\n            \"They should be handled by using the ProxyRequest object in the before handlers.\"\n        )\n\n    self._error_handler = error_handler\n    self._middlewares = defaultdict(list)\n\n    for item in middlewares or []:\n        self._middlewares[item.phase].append(item.middleware)\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.add_middleware","title":"<code>add_middleware(middleware_def)</code>","text":"<p>Register a middleware with explicit ordering.</p> <p>It will be registered depending on the order and relative to other defined middlewares. A lower number means sooner registration, while a higher number results in a later registration.</p> <p>Parameters:</p> Name Type Description Default <code>middleware_def</code> <code>ProxyMiddlewareDef</code> <p>The proxy middleware definition to add</p> required Source code in <code>aiorp/http_handler.py</code> <pre><code>def add_middleware(self, middleware_def: ProxyMiddlewareDef):\n    \"\"\"Register a middleware with explicit ordering.\n\n    It will be registered depending on the order and relative to\n    other defined middlewares. A lower number means sooner registration,\n    while a higher number results in a later registration.\n\n    Args:\n        middleware_def: The proxy middleware definition to add\n    \"\"\"\n    self._middlewares[middleware_def.phase].append(middleware_def.middleware)\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.client_edge","title":"<code>client_edge(func)</code>","text":"<p>Register an client edge middleware that can yield.</p> <p>This middleware is registered as first, meaning the code before yield will act before any other one, but code after yield will execute the last.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>ProxyMiddleware</code> <p>The middleware function which yields.</p> required <p>Returns:</p> Type Description <code>ProxyMiddleware</code> <p>The decorated middleware function.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>def client_edge(self, func: ProxyMiddleware) -&gt; ProxyMiddleware:\n    \"\"\"Register an client edge middleware that can yield.\n\n    This middleware is registered as first, meaning the code before yield\n    will act before any other one, but code after yield will execute the last.\n\n    Args:\n        func: The middleware function which yields.\n\n    Returns:\n        The decorated middleware function.\n    \"\"\"\n    self.add_middleware(ProxyMiddlewareDef(MiddlewarePhase.CLIENT_EDGE, func))\n    return func\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.proxy","title":"<code>proxy(func)</code>","text":"<p>Register a middleware with default execution order that can yield.</p> <p>Executes the pre-yield code before target edge, but after client edge middleware, and the post-yield code after target edge but before client edge middleware.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>ProxyMiddleware</code> <p>The middleware function which yields.</p> required <p>Returns:</p> Type Description <code>ProxyMiddleware</code> <p>The decorated middleware function.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>def proxy(self, func: ProxyMiddleware) -&gt; ProxyMiddleware:\n    \"\"\"Register a middleware with default execution order that can yield.\n\n    Executes the pre-yield code before target edge, but after client edge middleware,\n    and the post-yield code after target edge but before client edge middleware.\n\n    Args:\n        func: The middleware function which yields.\n\n    Returns:\n        The decorated middleware function.\n    \"\"\"\n    self.add_middleware(\n        ProxyMiddlewareDef(phase=MiddlewarePhase.PROXY, middleware=func)\n    )\n    return func\n</code></pre>"},{"location":"api_reference/HTTPProxyHandler/#aiorp.http_handler.HTTPProxyHandler.target_edge","title":"<code>target_edge(func)</code>","text":"<p>Register a target edge middleware that can yield.</p> <p>This middleware is registered the last. The code before yield will act after all other middlewares. The code after the yield runs before any other middleware.</p> <p>Parameters:</p> Name Type Description Default <code>func</code> <code>Callable[[ProxyContext], AsyncGenerator[None]]</code> <p>The middleware function which yields.</p> required <p>Returns:</p> Type Description <code>Callable[[ProxyContext], AsyncGenerator[None]]</code> <p>The decorated middleware function.</p> Source code in <code>aiorp/http_handler.py</code> <pre><code>def target_edge(\n    self, func: Callable[[ProxyContext], AsyncGenerator[None]]\n) -&gt; Callable[[ProxyContext], AsyncGenerator[None]]:\n    \"\"\"Register a target edge middleware that can yield.\n\n    This middleware is registered the last.\n    The code before yield will act after all other middlewares. The code after\n    the yield runs before any other middleware.\n\n    Args:\n        func: The middleware function which yields.\n\n    Returns:\n        The decorated middleware function.\n    \"\"\"\n    self.add_middleware(ProxyMiddlewareDef(MiddlewarePhase.TARGET_EDGE, func))\n    return func\n</code></pre>"},{"location":"api_reference/ProxyContext/","title":"ProxyContext","text":"<p>Proxy options used to configure the proxy handler.</p> <p>This class manages the context for proxy operations, including the target URL, session management, and request/response handling.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>URL</code> <p>The target URL to proxy requests to.</p> required <code>session_factory</code> <code>SessionFactory | None</code> <p>Optional factory function to create client sessions. If not provided, defaults to aiohttp.ClientSession.</p> <code>None</code> <code>state</code> <code>dict | None</code> <p>Optional state object to store additional context data.</p> <code>None</code> Source code in <code>aiorp/context.py</code> <pre><code>class ProxyContext:\n    \"\"\"Proxy options used to configure the proxy handler.\n\n    This class manages the context for proxy operations, including the target URL,\n    session management, and request/response handling.\n\n    Args:\n        url: The target URL to proxy requests to.\n        session_factory: Optional factory function to create client sessions.\n            If not provided, defaults to aiohttp.ClientSession.\n        state: Optional state object to store additional context data.\n    \"\"\"\n\n    def __init__(\n        self,\n        url: URL,\n        session_factory: SessionFactory | None = None,\n        state: dict | None = None,\n    ):\n        self.url: URL = url\n        self.state: dict | None = state\n        self.session_factory: SessionFactory = session_factory or ClientSession\n        self._request: ProxyRequest | None = None\n        self._response: ProxyResponse | None = None\n        self._ws_source: web.WebSocketResponse | None = None\n        self._ws_target: client.ClientWebSocketResponse | None = None\n        self._session: ClientSession | None = None\n\n    def __copy__(self) -&gt; \"ProxyContext\":\n        \"\"\"Copy the proxy context\n\n        Shares the session object, but creates a new instance for the state.\n\n        Returns:\n            A ProxyContext instance with a new instance of state,\n                but the same session object.\n        \"\"\"\n        ctx = ProxyContext(\n            url=self.url,  # Thread-safe design, always returns a new instance\n            state={**self.state} if self.state else None,\n            session_factory=self.session_factory,\n        )\n        # Set the session in case it is already there\n        ctx._session = self._session\n        return ctx\n\n    @property\n    def ws_source(self) -&gt; WebSocketResponse | None:\n        \"\"\"WebSocketResponse in charge of handling the server side socket with the client.\n\n        Returns:\n            The WebSocketResponse\n        \"\"\"\n        return self._ws_source\n\n    @property\n    def ws_target(self) -&gt; ClientWebSocketResponse | None:\n        \"\"\"ClientWebSocketResponse in charge of handling the client side socket\n        with the target server.\n\n        Returns:\n            The ClientWebSocketResponse\n        \"\"\"\n        return self._ws_target\n\n    @property\n    def response(self) -&gt; ProxyResponse:\n        \"\"\"Get the current proxy response.\n\n        Returns:\n            The current ProxyResponse object.\n\n        Raises:\n            ValueError: If the response has not been set yet.\n        \"\"\"\n        if self._response is None:\n            raise ValueError(\"Response is not yet set\")\n        return self._response\n\n    @property\n    def request(self) -&gt; ProxyRequest:\n        \"\"\"Get the current proxy request.\n\n        Returns:\n            The current ProxyRequest object.\n\n        Raises:\n            ValueError: If the request has not been set yet.\n        \"\"\"\n        if self._request is None:\n            raise ValueError(\"Request is not yet set\")\n        return self._request\n\n    def set_request(self, request: web.Request):\n        \"\"\"Set the current proxy request.\n\n        Args:\n            request: The incoming web request to proxy.\n        \"\"\"\n        self._request = ProxyRequest(\n            url=self.url,\n            in_req=request,\n        )\n\n    def set_response(self, response: client.ClientResponse):\n        \"\"\"Set the current proxy response.\n\n        Args:\n            response: The response from the target server.\n        \"\"\"\n        self._response = ProxyResponse(in_resp=response)\n\n    @property\n    def session(self) -&gt; ClientSession:\n        \"\"\"Get the session object, creating it if necessary.\n\n        Returns:\n            An active ClientSession instance.\n\n        Note:\n            If the session is closed or doesn't exist, a new one will be created\n            using the session factory.\n        \"\"\"\n        self.start_session()\n        return self._session\n\n    def start_session(self):\n        \"\"\"Build the session using the factory\"\"\"\n        if self._session is None or self._session.closed:\n            self._session = self.session_factory()\n\n    async def close_session(self):\n        \"\"\"Close the session object.\n\n        This method properly closes the current session and cleans up resources.\n        \"\"\"\n        if self._session is not None:\n            await self._session.close()\n        self._session = None\n\n    def set_socket_pair(\n        self, ws_source: WebSocketResponse, ws_target: ClientWebSocketResponse\n    ):\n        \"\"\"Set the socket pair used for tunneling messages\n\n        Args:\n            ws_source: The WebSocketResponse to set\n            ws_target: The ClientWebSocketResponse to set\n        \"\"\"\n        self._ws_source = ws_source\n        self._ws_target = ws_target\n\n    async def terminate_sockets(self):\n        \"\"\"Terminate the sockets if any are set\"\"\"\n        if self._ws_source and self._ws_target:\n            await self._ws_source.close()\n            await self._ws_target.close()\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.request","title":"<code>request</code>  <code>property</code>","text":"<p>Get the current proxy request.</p> <p>Returns:</p> Type Description <code>ProxyRequest</code> <p>The current ProxyRequest object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the request has not been set yet.</p>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.response","title":"<code>response</code>  <code>property</code>","text":"<p>Get the current proxy response.</p> <p>Returns:</p> Type Description <code>ProxyResponse</code> <p>The current ProxyResponse object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the response has not been set yet.</p>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.session","title":"<code>session</code>  <code>property</code>","text":"<p>Get the session object, creating it if necessary.</p> <p>Returns:</p> Type Description <code>ClientSession</code> <p>An active ClientSession instance.</p> Note <p>If the session is closed or doesn't exist, a new one will be created using the session factory.</p>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.ws_source","title":"<code>ws_source</code>  <code>property</code>","text":"<p>WebSocketResponse in charge of handling the server side socket with the client.</p> <p>Returns:</p> Type Description <code>WebSocketResponse | None</code> <p>The WebSocketResponse</p>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.ws_target","title":"<code>ws_target</code>  <code>property</code>","text":"<p>ClientWebSocketResponse in charge of handling the client side socket with the target server.</p> <p>Returns:</p> Type Description <code>ClientWebSocketResponse | None</code> <p>The ClientWebSocketResponse</p>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.__copy__","title":"<code>__copy__()</code>","text":"<p>Copy the proxy context</p> <p>Shares the session object, but creates a new instance for the state.</p> <p>Returns:</p> Type Description <code>ProxyContext</code> <p>A ProxyContext instance with a new instance of state, but the same session object.</p> Source code in <code>aiorp/context.py</code> <pre><code>def __copy__(self) -&gt; \"ProxyContext\":\n    \"\"\"Copy the proxy context\n\n    Shares the session object, but creates a new instance for the state.\n\n    Returns:\n        A ProxyContext instance with a new instance of state,\n            but the same session object.\n    \"\"\"\n    ctx = ProxyContext(\n        url=self.url,  # Thread-safe design, always returns a new instance\n        state={**self.state} if self.state else None,\n        session_factory=self.session_factory,\n    )\n    # Set the session in case it is already there\n    ctx._session = self._session\n    return ctx\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.close_session","title":"<code>close_session()</code>  <code>async</code>","text":"<p>Close the session object.</p> <p>This method properly closes the current session and cleans up resources.</p> Source code in <code>aiorp/context.py</code> <pre><code>async def close_session(self):\n    \"\"\"Close the session object.\n\n    This method properly closes the current session and cleans up resources.\n    \"\"\"\n    if self._session is not None:\n        await self._session.close()\n    self._session = None\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.set_request","title":"<code>set_request(request)</code>","text":"<p>Set the current proxy request.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Request</code> <p>The incoming web request to proxy.</p> required Source code in <code>aiorp/context.py</code> <pre><code>def set_request(self, request: web.Request):\n    \"\"\"Set the current proxy request.\n\n    Args:\n        request: The incoming web request to proxy.\n    \"\"\"\n    self._request = ProxyRequest(\n        url=self.url,\n        in_req=request,\n    )\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.set_response","title":"<code>set_response(response)</code>","text":"<p>Set the current proxy response.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>ClientResponse</code> <p>The response from the target server.</p> required Source code in <code>aiorp/context.py</code> <pre><code>def set_response(self, response: client.ClientResponse):\n    \"\"\"Set the current proxy response.\n\n    Args:\n        response: The response from the target server.\n    \"\"\"\n    self._response = ProxyResponse(in_resp=response)\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.set_socket_pair","title":"<code>set_socket_pair(ws_source, ws_target)</code>","text":"<p>Set the socket pair used for tunneling messages</p> <p>Parameters:</p> Name Type Description Default <code>ws_source</code> <code>WebSocketResponse</code> <p>The WebSocketResponse to set</p> required <code>ws_target</code> <code>ClientWebSocketResponse</code> <p>The ClientWebSocketResponse to set</p> required Source code in <code>aiorp/context.py</code> <pre><code>def set_socket_pair(\n    self, ws_source: WebSocketResponse, ws_target: ClientWebSocketResponse\n):\n    \"\"\"Set the socket pair used for tunneling messages\n\n    Args:\n        ws_source: The WebSocketResponse to set\n        ws_target: The ClientWebSocketResponse to set\n    \"\"\"\n    self._ws_source = ws_source\n    self._ws_target = ws_target\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.start_session","title":"<code>start_session()</code>","text":"<p>Build the session using the factory</p> Source code in <code>aiorp/context.py</code> <pre><code>def start_session(self):\n    \"\"\"Build the session using the factory\"\"\"\n    if self._session is None or self._session.closed:\n        self._session = self.session_factory()\n</code></pre>"},{"location":"api_reference/ProxyContext/#aiorp.context.ProxyContext.terminate_sockets","title":"<code>terminate_sockets()</code>  <code>async</code>","text":"<p>Terminate the sockets if any are set</p> Source code in <code>aiorp/context.py</code> <pre><code>async def terminate_sockets(self):\n    \"\"\"Terminate the sockets if any are set\"\"\"\n    if self._ws_source and self._ws_target:\n        await self._ws_source.close()\n        await self._ws_target.close()\n</code></pre>"},{"location":"api_reference/ProxyRequest/","title":"ProxyRequest","text":"<p>Proxy request object.</p> <p>This object encapsulates the incoming request and represents the request that will be sent to the target server. It exposes properties and methods to manipulate the request before it is executed.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>URL</code> <p>The target server URL.</p> required <code>in_req</code> <code>Request</code> <p>The incoming request object.</p> required Source code in <code>aiorp/request.py</code> <pre><code>class ProxyRequest:\n    \"\"\"Proxy request object.\n\n    This object encapsulates the incoming request and represents the request that will be sent\n    to the target server. It exposes properties and methods to manipulate the request before\n    it is executed.\n\n    Args:\n        url: The target server URL.\n        in_req: The incoming request object.\n    \"\"\"\n\n    HOP_BY_HOP_HEADERS = [\n        \"connection\",\n        \"keep-alive\",\n        \"proxy-authenticate\",\n        \"proxy-authorization\",\n        \"te\",\n        \"trailers\",\n        \"transfer-encoding\",\n        \"upgrade\",\n    ]\n\n    def __init__(\n        self,\n        url: URL,\n        in_req: web.Request,\n    ):\n        self.in_req: web.Request = in_req\n        self.url: URL = url\n        self.headers: CIMultiDict[str] = CIMultiDict(in_req.headers)\n        self.method: str = in_req.method\n        self.params: dict = dict(in_req.query)\n        self.content: bytes | Any = None\n\n        # Update path to match the incoming request\n        self.url = self.url.with_path(self.in_req.path)\n\n        # Update Host header with target server host\n        self.headers.update(host=self.url.host or \"\")\n\n        # Remove hop by hop headers\n        for header in self.HOP_BY_HOP_HEADERS:\n            self.headers.pop(header, None)\n\n        # Don't send default user-agent header if no other is provided\n        if \"user-agent\" not in self.headers:\n            self.headers[\"User-Agent\"] = \"\"\n\n        # Set the X-Forwarded-For header\n        self.set_x_forwarded_for()\n\n    def set_x_forwarded_for(self, clean: bool = False):\n        \"\"\"Set the X-Forwarded related headers.\n\n        By default, appends the current remote address to the existing X-Forwarded-For\n        header if one exists, and sets the X-Forwarded-Host header to the incoming host.\n        If clean is set to True, the existing X-Forwarded-For header will be ignored and\n        only the current remote address will be set.\n\n        Args:\n            clean: If True, ignore the existing X-Forwarded-For header.\n        \"\"\"\n        self.headers[\"X-Forwarded-Host\"] = self.in_req.host\n        if self.in_req.headers.get(\"X-Forwarded-For\") and not clean:\n            self.headers[\n                \"X-Forwarded-For\"\n            ] = f\"{self.in_req.headers['X-Forwarded-For']}, {self.in_req.remote}\"\n        elif self.in_req.remote:\n            self.headers[\"X-Forwarded-For\"] = self.in_req.remote\n\n    async def load_content(self):\n        \"\"\"Load the content of the incoming request if it can be read.\"\"\"\n        if self.method in [\"POST\", \"PUT\", \"PATCH\"] and self.in_req.can_read_body:\n            self.content = await self.in_req.read()\n</code></pre>"},{"location":"api_reference/ProxyRequest/#aiorp.request.ProxyRequest.load_content","title":"<code>load_content()</code>  <code>async</code>","text":"<p>Load the content of the incoming request if it can be read.</p> Source code in <code>aiorp/request.py</code> <pre><code>async def load_content(self):\n    \"\"\"Load the content of the incoming request if it can be read.\"\"\"\n    if self.method in [\"POST\", \"PUT\", \"PATCH\"] and self.in_req.can_read_body:\n        self.content = await self.in_req.read()\n</code></pre>"},{"location":"api_reference/ProxyRequest/#aiorp.request.ProxyRequest.set_x_forwarded_for","title":"<code>set_x_forwarded_for(clean=False)</code>","text":"<p>Set the X-Forwarded related headers.</p> <p>By default, appends the current remote address to the existing X-Forwarded-For header if one exists, and sets the X-Forwarded-Host header to the incoming host. If clean is set to True, the existing X-Forwarded-For header will be ignored and only the current remote address will be set.</p> <p>Parameters:</p> Name Type Description Default <code>clean</code> <code>bool</code> <p>If True, ignore the existing X-Forwarded-For header.</p> <code>False</code> Source code in <code>aiorp/request.py</code> <pre><code>def set_x_forwarded_for(self, clean: bool = False):\n    \"\"\"Set the X-Forwarded related headers.\n\n    By default, appends the current remote address to the existing X-Forwarded-For\n    header if one exists, and sets the X-Forwarded-Host header to the incoming host.\n    If clean is set to True, the existing X-Forwarded-For header will be ignored and\n    only the current remote address will be set.\n\n    Args:\n        clean: If True, ignore the existing X-Forwarded-For header.\n    \"\"\"\n    self.headers[\"X-Forwarded-Host\"] = self.in_req.host\n    if self.in_req.headers.get(\"X-Forwarded-For\") and not clean:\n        self.headers[\n            \"X-Forwarded-For\"\n        ] = f\"{self.in_req.headers['X-Forwarded-For']}, {self.in_req.remote}\"\n    elif self.in_req.remote:\n        self.headers[\"X-Forwarded-For\"] = self.in_req.remote\n</code></pre>"},{"location":"api_reference/ProxyResponse/","title":"ProxyResponse","text":"<p>Proxy response object.</p> <p>This object encapsulates the incoming request and the response from target server. It exposes a method to set the response object which can then be modified before being returned to the client.</p> <p>Parameters:</p> Name Type Description Default <code>in_resp</code> <code>ClientResponse</code> <p>The incoming response object.</p> required Source code in <code>aiorp/response.py</code> <pre><code>class ProxyResponse:\n    \"\"\"Proxy response object.\n\n    This object encapsulates the incoming request and the response from target server.\n    It exposes a method to set the response object which can then be modified before being\n    returned to the client.\n\n    Args:\n        in_resp: The incoming response object.\n    \"\"\"\n\n    def __init__(\n        self,\n        in_resp: client.ClientResponse,\n    ):\n        \"\"\"Initialize the proxy response object.\n\n        Args:\n            in_resp: The incoming response object.\n        \"\"\"\n        self.in_resp: client.ClientResponse = in_resp\n        self._web: web.StreamResponse | None = None\n        self._content: bytes | None = None\n\n    @property\n    def web_response_set(self) -&gt; bool:\n        \"\"\"Checks if the web response is set already.\n\n        Returns:\n            A boolean, true if set, false otherwise\n        \"\"\"\n        return self._web is not None\n\n    @property\n    def web(\n        self,\n    ) -&gt; StreamResponse | Response:\n        \"\"\"Access the web response.\n\n        Returns:\n            A response, either StreamResponse or Response.\n\n        Raises:\n            ValueError: When response is not set yet.\n        \"\"\"\n        if self._web is None:\n            raise ValueError(\"Response has not been set\")\n        return self._web\n\n    async def set_response(\n        self, response_type: ResponseType = ResponseType.BASE\n    ) -&gt; StreamResponse | Response:\n        \"\"\"Set the response using the given response type.\n\n        Args:\n            response_type: The type of response to set.\n\n        Returns:\n            The set web response.\n\n        Raises:\n            ValueError: When attempted to set the response a second time.\n        \"\"\"\n        if self._web is not None:\n            raise ValueError(\"Response can only be set once\")\n        if response_type == ResponseType.STREAM:\n            self._web = await self._get_stream_response()\n        else:\n            self._web = await self._get_base_response()\n        return self._web\n\n    async def _get_stream_response(self) -&gt; StreamResponse:\n        \"\"\"Convert incoming response to stream response.\"\"\"\n\n        headers = CIMultiDict(self.in_resp.headers)\n\n        # These headers should not be proxied\n        headers.pop(\"content-length\", None)\n        headers.pop(\"content-encoding\", None)\n        headers.pop(\"content-type\", None)\n\n        stream_resp = StreamResponse(\n            status=self.in_resp.status,\n            reason=self.in_resp.reason,\n            headers=self.in_resp.headers,\n        )\n        return stream_resp\n\n    async def _get_base_response(self) -&gt; Response:\n        \"\"\"Convert incoming response to base response.\"\"\"\n        content = await self.in_resp.read()\n\n        headers = CIMultiDict(self.in_resp.headers)\n\n        # These headers should not be proxied\n        headers.pop(\"content-length\", None)\n        headers.pop(\"content-encoding\", None)\n\n        if content:\n            headers[\"content-length\"] = str(len(content))\n\n        resp = Response(\n            status=self.in_resp.status,\n            reason=self.in_resp.reason,\n            headers=headers,\n            body=content,\n        )\n        return resp\n</code></pre>"},{"location":"api_reference/ProxyResponse/#aiorp.response.ProxyResponse.web","title":"<code>web</code>  <code>property</code>","text":"<p>Access the web response.</p> <p>Returns:</p> Type Description <code>StreamResponse | Response</code> <p>A response, either StreamResponse or Response.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When response is not set yet.</p>"},{"location":"api_reference/ProxyResponse/#aiorp.response.ProxyResponse.web_response_set","title":"<code>web_response_set</code>  <code>property</code>","text":"<p>Checks if the web response is set already.</p> <p>Returns:</p> Type Description <code>bool</code> <p>A boolean, true if set, false otherwise</p>"},{"location":"api_reference/ProxyResponse/#aiorp.response.ProxyResponse.__init__","title":"<code>__init__(in_resp)</code>","text":"<p>Initialize the proxy response object.</p> <p>Parameters:</p> Name Type Description Default <code>in_resp</code> <code>ClientResponse</code> <p>The incoming response object.</p> required Source code in <code>aiorp/response.py</code> <pre><code>def __init__(\n    self,\n    in_resp: client.ClientResponse,\n):\n    \"\"\"Initialize the proxy response object.\n\n    Args:\n        in_resp: The incoming response object.\n    \"\"\"\n    self.in_resp: client.ClientResponse = in_resp\n    self._web: web.StreamResponse | None = None\n    self._content: bytes | None = None\n</code></pre>"},{"location":"api_reference/ProxyResponse/#aiorp.response.ProxyResponse.set_response","title":"<code>set_response(response_type=ResponseType.BASE)</code>  <code>async</code>","text":"<p>Set the response using the given response type.</p> <p>Parameters:</p> Name Type Description Default <code>response_type</code> <code>ResponseType</code> <p>The type of response to set.</p> <code>BASE</code> <p>Returns:</p> Type Description <code>StreamResponse | Response</code> <p>The set web response.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>When attempted to set the response a second time.</p> Source code in <code>aiorp/response.py</code> <pre><code>async def set_response(\n    self, response_type: ResponseType = ResponseType.BASE\n) -&gt; StreamResponse | Response:\n    \"\"\"Set the response using the given response type.\n\n    Args:\n        response_type: The type of response to set.\n\n    Returns:\n        The set web response.\n\n    Raises:\n        ValueError: When attempted to set the response a second time.\n    \"\"\"\n    if self._web is not None:\n        raise ValueError(\"Response can only be set once\")\n    if response_type == ResponseType.STREAM:\n        self._web = await self._get_stream_response()\n    else:\n        self._web = await self._get_base_response()\n    return self._web\n</code></pre>"},{"location":"api_reference/Rewrite/","title":"Rewrite","text":"<p>Specifies a rewrite configuration for rewriting URL paths.</p> <p>This class defines a path rewriting rule that can be used to modify the path of incoming requests before they are proxied.</p> <p>Parameters:</p> Name Type Description Default <code>rfrom</code> <code>str</code> <p>The path pattern to match and replace.</p> required <code>rto</code> <code>str</code> <p>The replacement path pattern.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If only one of rfrom or rto is provided.</p> Source code in <code>aiorp/rewrite.py</code> <pre><code>class Rewrite:\n    \"\"\"Specifies a rewrite configuration for rewriting URL paths.\n\n    This class defines a path rewriting rule that can be used to modify\n    the path of incoming requests before they are proxied.\n\n    Args:\n        rfrom: The path pattern to match and replace.\n        rto: The replacement path pattern.\n\n    Raises:\n        ValueError: If only one of rfrom or rto is provided.\n    \"\"\"\n\n    def __init__(self, rfrom: str, rto: str):\n        \"\"\"Initialize the rewrite configuration.\n\n        Args:\n            rfrom: The path pattern to match and replace.\n            rto: The replacement path pattern.\n\n        Raises:\n            ValueError: If only one of rfrom or rto is provided.\n        \"\"\"\n        self.rfrom = rfrom\n        self.rto = rto\n\n    def execute(self, url: yarl.URL):\n        \"\"\"Rewrite the path of the request URL from current to new value.\n\n        Args:\n            url: The url to apply the rewrite to\n        \"\"\"\n        return url.with_path(url.path.replace(self.rfrom, self.rto))\n</code></pre>"},{"location":"api_reference/Rewrite/#aiorp.base_handler.Rewrite.__init__","title":"<code>__init__(rfrom, rto)</code>","text":"<p>Initialize the rewrite configuration.</p> <p>Parameters:</p> Name Type Description Default <code>rfrom</code> <code>str</code> <p>The path pattern to match and replace.</p> required <code>rto</code> <code>str</code> <p>The replacement path pattern.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If only one of rfrom or rto is provided.</p> Source code in <code>aiorp/rewrite.py</code> <pre><code>def __init__(self, rfrom: str, rto: str):\n    \"\"\"Initialize the rewrite configuration.\n\n    Args:\n        rfrom: The path pattern to match and replace.\n        rto: The replacement path pattern.\n\n    Raises:\n        ValueError: If only one of rfrom or rto is provided.\n    \"\"\"\n    self.rfrom = rfrom\n    self.rto = rto\n</code></pre>"},{"location":"api_reference/Rewrite/#aiorp.base_handler.Rewrite.execute","title":"<code>execute(url)</code>","text":"<p>Rewrite the path of the request URL from current to new value.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>URL</code> <p>The url to apply the rewrite to</p> required Source code in <code>aiorp/rewrite.py</code> <pre><code>def execute(self, url: yarl.URL):\n    \"\"\"Rewrite the path of the request URL from current to new value.\n\n    Args:\n        url: The url to apply the rewrite to\n    \"\"\"\n    return url.with_path(url.path.replace(self.rfrom, self.rto))\n</code></pre>"}]}